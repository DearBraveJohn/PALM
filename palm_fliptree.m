function Pset = palm_fliptree(Ptree,nP,cmc,maxP)
% Return a set of permutations from a permutation tree.
% 
% Usage:
% Sset = palm_fliptree(Ptree,nS,cmc,maxS)
% 
% Inputs:
% - Ptree : Tree with the dependence structure between
%           observations, as generated by 'palm_tree'.
% - nS    : Number of permutations. Use 0 for exhaustive.
% - cmc   : A boolean indicating whether conditional
%           Monte Carlo should be used or not. If not used,
%           there is a possibility of having repeated
%           permutations. The more possible permutations,
%           the less likely to find repetitions.
% - maxS  : (Optional) Maximum number of possible sign flips.
%           If not supplied, it's calculated internally. If
%           supplied, it's not calculated internally and some
%           warnings that could be printed are omitted.
%           Also, this automatically allows nS>maxS (via CMC).
%
% Outputs:
% - Sset  : A cell array of size nP by 1 containing sparse
%           sign-flipping matrices.
%
% _____________________________________
% Anderson M. Winkler
% FMRIB / University of Oxford
% Nov/2013
% http://brainder.org

% Note that the varnames follow the pattern of the similar
% function palm_permtree.m, for easier readability.

% Get the number of possible sign-flips.
if nargin <= 3,
    maxP = palm_maxshuf(Ptree,'flips');
    fprintf('Number of possible sign-flips is %g.\n',maxP);
    if nP > maxP,
        warning([...
            'The selected number of sign-flips (%g) is larger\n'         ...
            '         than the maximum number of possible flips (%g).\n' ...
            '         Computing %g flipping(s) instead.'],nP,maxP,maxP);
        nP = maxP;
    end
end

% Sign-flip #1 is no flip, regardless.
P = cell2mat(pickflip(Ptree,{},ones(size(Ptree,1)))');
P = horzcat(P,zeros(length(P),nP-1));

% All other sign flips up to nP
if nP == 0 || nP == maxP,
    
    % This will compute exhaustively all possible sign flips,
    % one branch at a time. If nP is too large print a warning.
    if nP > 1e5 && nargin <= 3;
        warning([...
            'Number of possible sign-flips is %g.\n' ...
            '         Performing all exhaustively.'],maxP);
    end
    for p = 2:maxP,
        Ptree  = nextflip(Ptree);
        P(:,p) = cell2mat(pickflip(Ptree,{},ones(size(Ptree,1)))');
    end
    
elseif cmc || nP > maxP,

    % Conditional Monte Carlo. Repeated sign flips allowed.
    for p = 2:nP,
        Ptree  = randomflip(Ptree);
        P(:,p) = cell2mat(pickflip(Ptree,{},ones(size(Ptree,1)))');
    end
    
else
    
    % Otherwise, repeated sign-flips are not allowed.
    % For this to work, maxP needs to be reasonably larger than
    % nP, otherwise it will take forever to run, so print a
    % warning.
    if nP > maxP/2 && nargin <= 3,
        warning([
            'The maximum number of sign flips (%g) is not much larger than\n' ...
            'the number you chose to run (%d). This means it may take a while (from\n' ...
            'a few seconds to several minutes) to find non-repeated sign flips.\n' ...
            'Consider instead running exhaustively all possible' ...
            'flips. It may be faster.'],maxP,nP);
    end
    
    % For each flip, keeps trying to find a new, non-repeated instance
    for p = 2:nP,
        whiletest = true;
        while whiletest,
            Ptree  = randomflip(Ptree);
            P(:,p) = cell2mat(pickflip(Ptree,{},ones(size(Ptree,1)))');
            whiletest = any(all(bsxfun(@eq,P(:,p),P(:,1:p-1))));
        end
    end
end

% Fix the sorting of rows
[~,idx] = palm_permtree(Ptree,1,false);
P = P(idx,:);

% For compatibility, convert each permutaion to a sparse permutation
% matrix. This section may be removed in the future if the
% remaining of the code is modified.
Pset = cell(nP,1);
for p = 1:nP,
    Pset{p} = sparse(diag(P(:,p)));
end

% ==============================================================
function [Ptree,incremented] = nextflip(Ptree)
% Make the next sign flip of tree branches, and returns
% the shuffled tree. This can be used to compute exhaustively
% all possible sign flippings.

% Some vars for later
nU = size(Ptree,1);

% For each branch of the current node
for u = 1:nU,
    if Ptree{u,2}(3) > 1,
        % If the branches at this node are to be considered
        % for sign-flippings (already being done or not)
        
        if Ptree{u,2}(4) < Ptree{u,2}(3)-1,
            % If the current branch can be flipped, but haven't
            % reached the last possibility yet, flip and break
            % the loop.
            Ptree{u,2}(4) = Ptree{u,2}(4) + 1;
            incremented = true;
            break;
            
        else
            % If the current branch could be flipped, and it's the
            % last possibility, reset it and don't break the loop.
            Ptree{u,2}(4) = 0;
            incremented = false;
        end
        
    else
        % If the branches at this node cannot be considered for
        % flipping, go to the deeper levels, if they exist.
        if size(Ptree{u,3},2) == 4,
            [Ptree{u,3},incremented] = nextflip(Ptree{u,3});
            if incremented,
                break;
            end
        end
    end
end

% ==============================================================
function Ptree = randomflip(Ptree)
% Make the a random sign-flip of all branches in the tree.

if size(Ptree,2) == 4;
    nU = size(Ptree,1);
    
    % For each branch of the current node
    for u = 1:nU,
        if Ptree{u,2}(3) > 1,
            % Make a random flip
            Ptree{u,2}(4) = randi(Ptree{u,2}(3))-1;
        else
            % Or go down more levels
            Ptree{u,3} = randomflip(Ptree{u,3});
        end
    end
end

% ==============================================================
function P = pickflip(Ptree,P,sgn)
% Take a tree in a given state and return the sign flip. This
% won't flip, only return the indices for the already flipped
% tree. This function is recursive and for the 1st iteration,
% P = {}, i.e., a 0x0 cell.

nU = size(Ptree,1);
if size(Ptree,2) == 4,
    for u = 1:nU,
        if Ptree{u,2}(3) > 1,
            bidx = de2bi(Ptree{u,2}(4),size(Ptree{u,3},1));
            bidx(~~bidx) = -1;
            bidx( ~bidx) =  1;
        else
            bidx = sgn(u)*ones(size(Ptree{u,3},1),1);
        end
        P = pickflip(Ptree{u,3},P,bidx);
    end
elseif size(Ptree,2) == 1,
    for u = 1:nU,
        if numel(sgn) == 1,
            v = 1;
        else
            v = u;
        end
        P{numel(P)+1} = sgn(v)*ones(size(Ptree{u}));
    end
end
