function Pset = palm_permtree(Ptree,nP,cmc)
% Return a set of permutations from a permutation tree.
% 
% Usage:
% Pset = palm_permtree(Ptree,nP,cmc)
% 
% - Ptree : Tree with the dependence structure between
%           observations, as generated by 'palm_tree'.
% - nP    : Number of permutations. Use 0 for exhaustive.
% - cmc   : A boolean indicating whether conditional
%           Monte Carlo should be used or not. If not used,
%           there is a possibility of having repeated
%           permutations. The more possible permutations,
%           the less likely to find repetitions.
% - Pset  : A cell array of size nP by 1 containing sparse
%           permutation matrices.
%
% _____________________________________
% Anderson M. Winkler
% FMRIB / University of Oxford
% Oct/2013
% http://brainder.org

% Get the number of possible permutations.
maxP = palm_maxnperm(Ptree);
fprintf('Number of possible permutations is %g\n',maxP);

if nP > maxP,
    warning([...
        'The selected number of permutations (%d) is larger than\n'    ...
        '         the maximum number of possible permutations (%g).\n' ...
        '         Computing %g permutation(s) instead.'],nP,maxP);
    nP = maxP;
end

% Permutation #1 is no permutation, regardless.
P = cell2mat(pickperm(Ptree,{})');
P = horzcat(P,zeros(length(P),nP-1));

% All other permutations up to nP
if nP == 0 || nP == maxP,

    % This will compute exhaustively all possible permutations,
    % shuffling one branch at a time. If nP is too large,
    % print a warning.
    if nP > 1e5;
        warning([...
            'Number of possible permutations is %g.\n' ...
            '         Performing all exhaustively.'],maxP);
    end
    for p = 2:maxP,
        Ptree  = nextperm(Ptree);
        P(:,p) = cell2mat(pickperm(Ptree,{})');
    end
    
elseif cmc,

    % Conditional Monte Carlo. Repeated permutations allowed.
    for p = 2:nP,
        Ptree  = randomperm(Ptree);
        P(:,p) = cell2mat(pickperm(Ptree,{})');
    end
    
else
    
    % Otherwise, repeated permutations are not allowed.
    % For this to work, maxP needs to be reasonably larger than
    % nP, otherwise it will take forever to run, so print a
    % warning.
    if nP > maxP/2,
        warning([
            'The maximum number of permutations (%g) is not much larger the\n'            ...
            'number of permutations you chose to run (%d). This means it may\n'           ...
            'take a while (from a few seconds to several minutes) to find non-repeated\n' ...
            'permutations. Consider instead running exhaustively all possible'            ...
            'permutations as it may be faster.'],maxP,nP);
    end
    
    % For each perm, keeps trying to find a new, non-repeated
    % permutation.
    for p = 2:nP,
        whiletest = true;
        while whiletest,
            Ptree  = randomperm(Ptree);
            P(:,p) = cell2mat(pickperm(Ptree,{})');
            whiletest = any(all(bsxfun(@eq,P(:,p),P(:,1:p-1))));
        end
    end
end

% The grouping into branches screws up the original order, which
% can be restored by noting that the 1st permutation is always
% the identity, so with indices 1:N.
P = sortrows(P);

% For compatibility, convert each permutaion to a sparse permutation
% matrix. This section will be removed in the future once the
% remaining of the code has been modified.
Pset = cell(nP,1);
for p = 1:nP,
    Pset{p} = palm_idx2perm(P(:,p));
end

% ==============================================================
function [Ptree,flagfin] = nextperm(Ptree)
% Make the next single shuffle of tree branches, and returns
% the shuffled tree. This can be used to compute exhaustively
% all possible permutations.

% Some vars for later
nU   = size(Ptree,1);
ufin = false(nU,1);

% For each branch of the current node
for u = 1:nU,
    
    if Ptree{u,2}(2) == 0,
        
        % If [0 0] or [1 0], i.e., if there are permutations
        % to go at this node or deeper, go there.
        [Ptree{u,4},Ptree{u,2}(2)] = nextperm(Ptree{u,4});
        
        % If it didn't finish, reset the previous branches in this level,
        % and break the loop
        if Ptree{u,2}(2) == 0,
            break;
        end
    end
    
    if Ptree{u,2}(1) == 0,
        
        % If [0 1] or [0 NaN] (note it's not necessary to test the 2nd
        % element because if it were 0, it would have been caught above),
        % i.e., if all deeper nodes are known to have finished, but this
        % node itself can be shuffled, permute it, then start permuting
        % these deeper nodes again.
        tmp = palm_nextperm(Ptree{u,1});
        if tmp(1),
            
            % If the next permutation, just computed, is valid, i.e.,
            % not the last, permute then the original branches (as the
            % indices refer to the original, not to the previous state)
            % and leave the loop.
            Ptree{u,1} = tmp;
            Ptree{u,4} = Ptree{u,3}(Ptree{u,1},:);
            if ~ isnan(Ptree{u,2}(2)),
                Ptree{u,2}(2) = 0;
            end
            if u > 1,
                Ptree(1:u-1,4) = Ptree(1:u-1,3);
                for u1 = 1:u-1,
                    Ptree{u1,1} = flipud(Ptree{u1,1});
                    Ptree{u1,2}(1) = 0;
                    if isnan(Ptree{u1,2}(2)),
                        Ptree{u1,2}(2) = NaN;
                    else
                        Ptree{u1,2}(2) = 0;
                    end
                end
                ufin(1:u-1) = false;
            end
            break;
            
        else
            
            % If the next permutation, just computed, is invalid, i.e.,
            % the previous was the last one, then mark this branch as
            % finished, and continue in the for-loop to see if something
            % can be permuted in the next branch in this same level. This
            % can't happen, however, if this block has a single
            % observation, in which case, it's ignored as if non-existing.
            Ptree{u,2}(1) = 1;
        end        
    end
    
    % If it reached here, this means the loop wasn't broken, which means
    % there were no more permutations to do at the current or deeper
    % nodes, i.e., [1 1] for all. If this is the case, pass this
    % information to the higher level.
    ufin(u) = true;
end

% Pass along to the upper level the information that all the branches at
% this node finished (or not).
flagfin = all(ufin);

% ==============================================================
function Ptree = randomperm(Ptree)
% Make the a random shuffling of all branches in the tree.

% For each branch of the current node
nU = size(Ptree,1);
for u = 1:nU,
    
    % Make sure this isn't within-block at 1st level (marked as NaN)
    if ~ isnan(Ptree{u,1}),
        Ptree{u,1} = Ptree{u,1}(randperm(numel(Ptree{u,1})));
        Ptree{u,4} = Ptree{u,3}(Ptree{u,1},:);
    end
    
    % Make sure this isn't the last level (marked as NaN).
    if ~ isnan(Ptree{u,2})
        Ptree{u,4} = randomperm(Ptree{u,4});
    end
end

% ==============================================================
function P = pickperm(Ptree,P)
% Take a tree in a given state and return the permutation. This
% won't permute, only return the indices for the already permuted
% tree. This function is recursive and for the 1st iteration,
% P = {}, i.e., a 0x0 cell.

nU = size(Ptree,1);
if size(Ptree,2) == 4,
    for u = 1:nU,
        P = pickperm(Ptree{u,4},P);
    end
elseif size(Ptree,2) == 1,
    for u = 1:nU,
        P{numel(P)+1} = Ptree{u,1};
    end
end
